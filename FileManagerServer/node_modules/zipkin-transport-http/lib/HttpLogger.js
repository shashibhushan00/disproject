'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/* eslint-disable no-console */
var globalFetch = typeof window !== 'undefined' && window.fetch || typeof global !== 'undefined' && global.fetch;

// eslint-disable-next-line global-require
var fetch = globalFetch || require.call(null, 'node-fetch');

var _require = require('zipkin'),
    JSON_V1 = _require.jsonEncoder.JSON_V1;

var EventEmitter = require('events').EventEmitter;

var HttpLogger = function (_EventEmitter) {
  _inherits(HttpLogger, _EventEmitter);

  function HttpLogger(_ref) {
    var endpoint = _ref.endpoint,
        _ref$headers = _ref.headers,
        headers = _ref$headers === undefined ? {} : _ref$headers,
        _ref$httpInterval = _ref.httpInterval,
        httpInterval = _ref$httpInterval === undefined ? 1000 : _ref$httpInterval,
        _ref$jsonEncoder = _ref.jsonEncoder,
        jsonEncoder = _ref$jsonEncoder === undefined ? JSON_V1 : _ref$jsonEncoder,
        _ref$timeout = _ref.timeout,
        timeout = _ref$timeout === undefined ? 0 : _ref$timeout;

    _classCallCheck(this, HttpLogger);

    // must be before any reference to *this*
    var _this = _possibleConstructorReturn(this, (HttpLogger.__proto__ || Object.getPrototypeOf(HttpLogger)).call(this));

    _this.endpoint = endpoint;
    _this.queue = [];
    _this.jsonEncoder = jsonEncoder;

    _this.errorListenerSet = false;

    _this.headers = Object.assign({
      'Content-Type': 'application/json'
    }, headers);

    // req/res timeout in ms, it resets on redirect. 0 to disable (OS limit applies)
    // only supported by node-fetch; silently ignored by browser fetch clients
    // @see https://github.com/bitinn/node-fetch#fetch-options
    _this.timeout = timeout;

    var timer = setInterval(function () {
      _this.processQueue();
    }, httpInterval);
    if (timer.unref) {
      // unref might not be available in browsers
      timer.unref(); // Allows Node to terminate instead of blocking on timer
    }
    return _this;
  }

  _createClass(HttpLogger, [{
    key: 'on',
    value: function on() {
      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      var eventName = args[0];
      // if the instance has an error handler set then we don't need to
      // console.log errors anymore
      if (eventName.toLowerCase() === 'error') this.errorListenerSet = true;
      _get(HttpLogger.prototype.__proto__ || Object.getPrototypeOf(HttpLogger.prototype), 'on', this).apply(this, args);
    }
  }, {
    key: 'logSpan',
    value: function logSpan(span) {
      this.queue.push(this.jsonEncoder.encode(span));
    }
  }, {
    key: 'processQueue',
    value: function processQueue() {
      var _this2 = this;

      var self = this;
      if (self.queue.length > 0) {
        var postBody = '[' + self.queue.join(',') + ']';
        fetch(self.endpoint, {
          method: 'POST',
          body: postBody,
          headers: self.headers,
          timeout: self.timeout
        }).then(function (response) {
          if (response.status !== 202) {
            var err = 'Unexpected response while sending Zipkin data, status:' + (response.status + ', body: ' + postBody);

            if (self.errorListenerSet) _this2.emit('error', new Error(err));else console.error(err);
          }
        }).catch(function (error) {
          var err = 'Error sending Zipkin data ' + error;
          if (self.errorListenerSet) _this2.emit('error', new Error(err));else console.error(err);
        });
        self.queue.length = 0;
      }
    }
  }]);

  return HttpLogger;
}(EventEmitter);

module.exports = HttpLogger;